# 트리(Tree)
## 트리가 왜 생겨났을까?

배열이나 연결리스트는 데이터를 일렬로 저장하기 때문에 탐색  연산이 순차적으로 수행되어야 한다는 단점을 가진다. 배열은 미리 정렬해 놓으면 이진탐색을 통해 효율적인 탐색이 가능하지만, 삽입이나 삭제 후에도 정렬 상태를 유지해야 하므로 삽입이나 삭제하는데 O(N) 시간이 소요된다. 이러한 문제점을 보완한 계층적(Hierarchical) 자료 구조가 트리(Tree)이다.

## 트리의 정의

트리는 Empty이거나, Empty가 아니면 루트노트 R과 트리의 집합으로 구서오디는데 각 트리의 루트노드는 R의 자식노드이다. 단, 트리의 집합은 공집할일 수도 있다.

## 트리의 용어

- 루트(Root) 노드 : 트리의 최상위에 있는 노드
- 부모(Parent) 노드 : 노드 상위에 연결된 노드
- 자식(Child) 노드 : 노드 하위에 연결된 노드
- 차수(Degree) 노드 : 자식 노드 수
- 형제(Sibling) 노드 : 동일한 부모를 가지는 노드
- 조상(Ancestor) 노드 : 루트 노드까지의 경로상에 있는 모든 노드들의 집합
- 후손(Descendant) 노드 : 노드 아래로 매달린 모든 노드들의 집합
- 서브트리(Subtree) : 노드 자신과 후손 노드로 구성된 트리
- 레벨(Level) : 루트 노드가 레벨 1에 있고 아래로 내려가며 레벨이 1씩 증가한다. 레벨은 깊이(Depth)와 같다
- 높이(Height) : 트리의 최대 레벨
- 키(Key) : 탐색에 사용되는 노드에 저장된 정보
- 이파리(Leaf) 노드 : 자식이 없는 노드, 단말(Terminal) 노드 또는 외부(External) 노드라고도 한다. 이파리가 아닌 노드를 비 단말(Non-Terminal) 노드 또는 내부(Internal) 노드라고 한다

## 트리의 저장

일번적인 트리를 메모리에 저장하려면 각 노드에 키와 자식 수만큼의 레퍼런스를 저장해야 한다. 따라서 트리 노드의 최대 차수가 k라면, `k+1`개의 레퍼런스 필드를 선언해야 한다.

최대 차수가 k인 트리에 N개의 노드가 있다면, null 레퍼런스 수는 `Nk - (N-1) = N(k-1) + 1` 이다. 여기서 `Nk`는 총 레퍼런스 수이고, `N-1`은 트리에서 실제 부모 자식을 연결하는 레퍼런스 수이다. 

- 이파리노드도 k개의 레퍼런스를 가지고 있다.
- 2개의 노드를 연결하기 위해선 1개의 선이 필요하고, N개의 노드를 연결하기 위해선 `N-1`개의 선이 필요하다

따라서 k가 클수록 메모리의 낭비가 심해지는 것은 물론 트리를 탐색하는 과정에서 null 레퍼런스를 확인해야 하므로 시간적으로도 매우 비효율적이다. 

## 왼쪽자식 - 오른쪽 형제 (LCRS)

왼쪽자식 - 오른쪽형제(Left Child - Right Sibling) 표현은 이러한 단점을 보완해주는 자료 구조이다. 이 자료구조는 노드의 왼쪽 자식과 왼쪽 자식의 오른쪽 형제 노드를 가리키는 2개의 레퍼런스만을 사용하여 노드를 표현한다.

왼쪽 자식 - 오른쪽 형제는 노드의 차수가 일정하지 않은 일반적인 트리를 구현하는 매우 효율적인 자료구조이다.

## 이진트리(Binary Tree)

각 노드의 자식 수가 2 이하인 트리이다.

## 정의

이진 트리는 Empty이거나, 루트 노드와 2개의 이진트리인 왼쪽 서브트리와 오른쪽 서브트리로 구성된다.

- Empty(Root = null)여도 이진트리이다!

## 장점

- 데이터의 구조적인 관계를 잘 반영한다
- 효율적인 삽입과 탐색을 가능하게 한다
- 이진트리의 서브트리를 다른 이진트리의 서브트리와 교환하는 것이 쉽다

## 포화 이진 트리(Full Binary Tree)

모든 이파리 노드의 깊이가 같고 각 내부 노드가 2개의 자식노드를 가지는 트리이다. 

## 이진트리의 연산

이진트리에서 수행되는 기본 연산들은 트리를 순회(Traversal)하며 이루어진다.

방식은 각각 다르지만 순회는 항상 트리의 루트 노드로부터 시작

모든 순회 방식은 루트 노드로부터 순회를 시작하여 트리의 각 노드를 반드시 1번씩 방문해야 순회가 종료된다.

## 전위 순회(PreOrder)

1. 노드 x에 도착했을 때 x를 방문
2. x의 왼쪽 자식 노드로 순회를 계속
3. x의 왼쪽 서브트리의 모든 노드들을 방문한 후에는 x의 오른쪽 서브트리의 모든 후손 노드들을 방문

전위 순회 순서를 NLR 또는 VLR로 표현한다.

여기서 N은 Node, V는 Visit를 의미한다. L은 Left, R은 Right를 의미한다.

## 중위 순회(InOrder)

1. 노드 x에 도착하면 x의 방문을 보류하고 x의 왼쪽 서브트리로 순회를 진행
2. 읜쪽 서브트리의 모든 노드들을 방문한 후에 x를 방문
3. x를 방문한 후에는 x의 오른쪽 서브트리를 같은 방식으로 방문

중위 순회 순서를 LNR 또는 LVR로 표현한다.

## 후위 순회(PostOrder)

1. 노드 x에 도착하면 x의 방문을 보류, x의 왼쪽 서브트리로 순회를 진행한다
2. x의 왼쪽 서브트리를 방문한 후에는 x의 오른쪽 서브트리를 순회
3. 마지막에 x를 방문한다

후위 순회 순서를 LRN 또는 LRV로 표현한다

## 레벨 순회(Level Order Traversal)

루트 노드가 있는 최상위 레벨부터 시작하여 각 레벨마다 좌에서 우로 노드들을 방문한다.

큐 자료 구조를 활용한다.

## 기타 이진 트리 연산

size()와 height() 는 후위 순회에 기반하고, isEqual()은 전위 순회에 기반

2개의 이진트리를 비교하는 것은 다른 부분을 발견하는 즉시 비교 연산을 멈추기 위해 전위 순회 방법을 사용한다.

## 트리의 노드 수(size)

트리의 노드 수 = 1(루트 노드) + ( 루트 노드의 왼쪽 서브 트리에 있는 노드 수 ) + ( 루트 노드의 오른쪽 서브 트리에 있는 노드 수 )

트리의 아래에서 위로 각 자식의 후손 노드 수를 합하며 올라가는 과정을 통해 수행되며, 최종적으로 루트 노드에서 합산한다

노드가 null이면 0을 리턴한다.

null이 아니면 왼쪽 자식 노드를 루트 노드로 하는 서브 트리의 노드 수와 오른쪽 자식 노드를 루트 노드로 하는 서브 트리의 노드 수를 더한 결과에 1을 더합 값을 리턴한다.

## 트리의 높이(height)

트리의 높이 = 1(루트 노드) + Math.max(루트 노드의 왼쪽 서브트리의 높이, 루트 노드의 오른쪽 서브 트리의 높이)

노드가 null 이면 0을 리턴한다.

null이 아니면 왼쪽 자식 노드를 루트 노드로 하는 서브 트리의 높이와 오른쪽 자식 노드를 루트 노드로 하는 서브트리의 높이 중에서 보다 큰 높이에 1을 더한 값을 리턴한다.

## 이진 트리의 비교

전위 순회 과정에서 다른 점이 발견된 순간 false를 리턴한다.

## 수행 시간

트리의 각 노드를 한 번씩만 방문하므로 O(N) 시간이 소요된다

## 스택없이 이진 트리의 연산을 구현하는 방법

이진 트리의 기본 연산들은 레벨 순회를 제외하고 모두 스택 자료구조를 사용한다. 메소드의 재귀호출은 시스템 스택을 사용하므로 스택 자료구조를 사용한 것으로 간주한다.

스택에 사용되는 메모리 공간의 크기는 트리의 높이에 비례한다.

- Node에 부모 노드를 가리키는 레퍼런스 필드를 추가로 선언하여 순회에 사용하는 방법
- null 레퍼런스 공간에 다음에 방문할 노드의 레퍼런스를 저장한다. 이렇게 만든 이진 트리를 스레드 이진트리(Threaded Binary Tree)라고 한다.

## 스레드 이진트리(Threaded Binary Tree)

null 레퍼런스를 활용하여 이전에 방문한 노드와 다음에 방문할 노드를 가리키도록 만들어 순회 연산이 스택 없이도 수행될 수 있도록 만든 트리이다.

```
N개의 이진트리에 존재하는 null 레퍼런스 수 = Nk - ( N - 1 )  = N+1
```

- 운영체제에서 스케쥴러가 운영하는 독립적인 수행단위인 스레드와는 전혀 관계없는 단어이다

## 장점

- 스택을 사용하는 순회보다 빠르고 메모리 공간도 적게 차지한다

## 단점

- 데이터의 삽입과 삭제가 잦은 경우 그 구현이 비교적 복잡한 편이므로 좋은 성능을 보여주지 못한다

Node 객체에 2개의 boolean 필드를 사용하여 레퍼런스가 스레드(다음 방문할 노드를 가리키는)로 사용되는 것인지 아니면 left나 right가 트리의 부모 자식 사이의 레퍼런스인지를 true나 false로 표시해주어야 한다.